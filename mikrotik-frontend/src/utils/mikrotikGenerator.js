export const generateMikrotikScript = (config = {}) => {
  const { 
    selectedModel,
    wanList = [], 
    networks = [], 
    portConfig = {}, 
    pbrConfig = { enabled: false, mappings: {} }, 
    dnsConfig = { servers: ['8.8.8.8', '1.1.1.1'], allowRemoteRequests: true }, 
    wirelessConfig = {},
    circuitId = 'MikroTik-Router', 
    token = ''
  } = config;

  const bridgeName = "bridge-trunk";
  
  const isProd = import.meta.env?.PROD || false;
  const fetchExtras = isProd ? "check-certificate=no" : "";

  const currentHost = window.location.hostname;
  const currentProtocol = window.location.protocol;
  const isLocal = currentHost === 'localhost' || 
                  currentHost === '127.0.0.1' || 
                  currentHost.startsWith('192.168.') || 
                  currentHost.startsWith('10.') || 
                  currentHost.startsWith('172.');

  const dynamicApiUrl = isLocal 
    ? `http://${currentHost}:3000/api/devices/heartbeat`
    : `${currentProtocol}//${currentHost}/api/devices/heartbeat`;

  const finalApiUrl = import.meta.env?.VITE_HEARTBEAT_URL || dynamicApiUrl;

  const wanInterfaces = wanList.map(w => w.interface);
  const lanPorts = selectedModel?.ports?.filter(p => !wanInterfaces.includes(p.name) && p.type !== 'WLAN') || [];

  // IP สำหรับ Monitor Route
  const monitorIps = ['1.1.1.1', '203.159.77.77', '8.8.8.8', '203.113.127.199', '1.1.1.1'];

  try {
    let script = `################################################\n`;
    script += `# Generated by Mikrotik Config Wizard\n`;
    script += `# Environment: ${isProd ? 'Production' : 'Development'}\n`;
    script += `# Date: ${new Date().toLocaleString()}\n`;
    script += `# Identity: ${circuitId}\n`;
    script += `################################################\n\n`;

    // --- 1. INITIAL SETUP ---
    script += `/system identity set name="${circuitId}"\n`;
    script += `/interface bridge add name=${bridgeName} comment="Main LAN Bridge" vlan-filtering=no\n`;

    script += `\n# --- Interface Lists ---\n`;
    script += `/interface list add name=WAN\n`;
    script += `/interface list add name=LAN\n`;
    script += `/interface list member add interface=${bridgeName} list=LAN\n\n`;

    script += `/system clock set time-zone-name=Asia/Bangkok\n`;
    script += `/system ntp client set enabled=yes servers=time.google.com,time1.google.com\n`;

    script += `/user add name=ntadmin group=full password="ntadmin" comment="Created by Wizard"\n`;
    script += `/user remove [find name!=ntadmin]\n`;

    script += `/ip service set telnet disabled=yes\n`;
    script += `/ip service set ftp disabled=yes\n`;
    script += `/ip service set www disabled=yes\n`;
    script += `/ip service set ssh disabled=yes\n`;
    script += `/ip service set api disabled=yes\n`;
    script += `/ip service set api-ssl disabled=yes\n`;
    script += `/ip service set winbox disabled=no\n`;

    script += `/ip neighbor discovery-settings set discover-interface-list=LAN\n`;
    script += `/tool mac-server set allowed-interface-list=LAN\n`;
    script += `/tool mac-server mac-winbox set allowed-interface-list=LAN\n`;
    script += `/tool mac-server ping set enabled=no\n`;

    // --- 2. ADDRESS LISTS ---
    script += `\n# --- Address Lists ---\n`;
    script += `/ip firewall address-list remove [find list="Local_Networks"]\n`;
    script += `/ip firewall address-list remove [find list="management"]\n`;
    
    script += `/ip firewall address-list add list=management address=10.234.56.0/24 comment="Default Management"\n`;
    
    networks.forEach(net => {
       script += `/ip firewall address-list add list=Local_Networks address=${net.ip} comment="${net.name}"\n`;
    });

    // --- 3. WAN SETUP ---
    script += `\n# --- WAN Interface Setup ---\n`;

    wanList.forEach((wan, index) => {
      const i = index + 1;
      const wanName = `wan${i}-${wan.interface}`;
      const monitorIp = monitorIps[index % monitorIps.length];
      wan.monitorIp = monitorIp;

      script += `:do { /interface set [find default-name=${wan.interface}] name=${wanName} comment="WAN ${i}" } on-error={ :log error "WAN Interface ${wan.interface} not found" }\n`;

      let actualGw = '';
      if (wan.type === 'pppoe') {
        script += `/interface pppoe-client add name="pppoe-out${i}" interface=${wanName} user="${wan.username}" password="${wan.password}" disabled=no add-default-route=no use-peer-dns=yes\n`;
        script += `/interface list member add interface=pppoe-out${i} list=WAN\n`;
        actualGw = `pppoe-out${i}`;
      } else {
        script += `/ip address add address=${wan.ipAddress} interface=${wanName} comment="Static WAN"\n`;
        script += `/interface list member add interface=${wanName} list=WAN\n`;
        actualGw = wan.gateway;
      }
      wan.actualGw = actualGw; // เก็บ Gateway จริงไว้ใช้สร้าง Route
    });

    // --- สร้าง Route ใน Main Table ตามแบบฉบับของคุณ ---
    script += `\n# --- Main Routing Table (Host Routes & Fallbacks) ---\n`;
    script += `/ip route\n`;
    wanList.forEach((wan, index) => {
      const i = index + 1;
      // Host Route สำหรับ Ping (กำหนด Scope=10)
      script += `add dst-address=${wan.monitorIp}/32 gateway=${wan.actualGw} scope=10 comment="Host Route for WAN${i}"\n`;
      // Default Route สำหรับตัวเราเตอร์เองและทราฟฟิกที่ไม่ได้ทำ PBR
      script += `add dst-address=0.0.0.0/0 gateway=${wan.actualGw} distance=${i} check-gateway=ping comment="Main Default Route WAN${i}"\n`;
    });

    // --- 4. LAN & VLAN SETUP ---
    script += `\n# --- LAN & VLAN Interfaces ---\n`;
    networks.forEach(net => {
      const vlanInterface = `${net.name}-v${net.vlanId}`;
      script += `/interface vlan add interface=${bridgeName} name=${vlanInterface} vlan-id=${net.vlanId}\n`;
      script += `/ip address add address=${net.ip} interface=${vlanInterface} comment="${net.name} Gateway"\n`;
      
      const [gatewayIP, cidr] = net.ip.split('/');
      const ipParts = gatewayIP.split('.');
      ipParts.pop(); 
      const networkAddr = `${ipParts.join('.')}.0/${cidr}`;
      const poolName = `pool-${net.name}`;

      const clientDnsServers = dnsConfig.allowRemoteRequests ? gatewayIP : dnsConfig.servers.join(',');

      if (net.dhcp || net.hotspot) {
        const poolRange = `${ipParts.join('.')}.10-${ipParts.join('.')}.254`;
        script += `/ip pool add name="${poolName}" ranges=${poolRange}\n`;
        script += `/ip dhcp-server add name="dhcp-${net.name}" interface=${vlanInterface} address-pool="${poolName}" disabled=no lease-time=1d\n`;
        script += `/ip dhcp-server network add address=${networkAddr} gateway=${gatewayIP} dns-server=${clientDnsServers}\n`;
      }

      if (net.hotspot) {
        script += `\n  # --- Hotspot Server: ${net.name} ---\n`;
        script += `  /ip hotspot profile add name="hsprof-${net.name}" hotspot-address=${gatewayIP} dns-name="login.wifi.local" login-by=mac-cookie,http-pap\n`;
        script += `  /ip hotspot add name="hs-${net.name}" interface=${vlanInterface} address-pool="${poolName}" profile="hsprof-${net.name}" disabled=no\n\n`;
      }
    });

    // --- 5. PORT ASSIGNMENT ---
    if (lanPorts.length > 0) {
      script += `\n# --- Port Assignment ---\n`;
      const defaultPvid = networks.length > 0 ? Number(networks[0].vlanId) : 1;

      lanPorts.forEach(port => {
         const pConfig = portConfig[port.name] || { mode: 'access', pvid: defaultPvid, nativeVlan: 1, allowed: [] };
         const portPvid = pConfig.mode === 'access' ? (pConfig.pvid || defaultPvid) : (pConfig.nativeVlan || 1);

         script += `:do { /interface bridge port add bridge=${bridgeName} interface=${port.name} pvid=${portPvid} comment="LAN Port (${pConfig.mode})" } on-error={ :log warning "Wizard: Port ${port.name} not found" }\n`;
      });
    }

    // --- 6. WIRELESS CONFIGURATION ---
    if (wirelessConfig && Object.keys(wirelessConfig).length > 0) {
      script += `\n# --- Wireless Setup ---\n`;
      Object.entries(wirelessConfig).forEach(([portName, config]) => {
        if (!config.ssid) return;
        const secProfileName = `sec_profile_${portName}`;
        script += `/interface wireless security-profiles\n`;
        if (config.security === 'none') {
          script += `add name="${secProfileName}" mode=none\n`;
        } else {
          const authTypes = config.security === 'wpa2-wpa3-psk' ? 'wpa2-psk,wpa3-psk' : 'wpa2-psk';
          script += `add name="${secProfileName}" mode=dynamic-keys authentication-types="${authTypes}" wpa2-pre-shared-key="${config.password}" ${config.security === 'wpa2-wpa3-psk' ? `wpa3-pre-shared-key="${config.password}"` : ''}\n`;
        }
        script += `/interface wireless\n`;
        script += `:do { set [ find default-name="${portName}" ] mode=ap-bridge ssid="${config.ssid}" security-profile="${secProfileName}" disabled=no ${config.band ? `band="${config.band}"` : ''} } on-error={}\n`;
        script += `:do { /interface bridge port add bridge=${bridgeName} interface=${portName} pvid=1 comment="WLAN Port" } on-error={}\n`;
      });
    }

    // --- 7. BRIDGE VLAN FILTERING TABLE ---
    if (networks.length > 0) {
      script += `\n# --- Bridge VLAN Table ---\n`;
      script += `/interface bridge vlan\n`;

      networks.forEach(net => {
        const vlanId = net.vlanId;
        const taggedPorts = [bridgeName];

        lanPorts.forEach(port => {
          const pConfig = portConfig[port.name];
          if (pConfig && pConfig.mode === 'trunk' && pConfig.allowed && pConfig.allowed.includes(vlanId)) {
            taggedPorts.push(port.name);
          }
        });

        script += `add bridge=${bridgeName} tagged=${taggedPorts.join(',')} vlan-ids=${vlanId}\n`;
      });
    }

    // --- 8. DNS & FIREWALL ---
    script += `\n# --- DNS & Firewall ---\n`;
    script += `/ip dns set servers=${dnsConfig.servers.join(',')} allow-remote-requests=${dnsConfig.allowRemoteRequests ? 'yes' : 'no'}\n`;
    script += `/ip firewall nat add chain=srcnat action=masquerade out-interface-list=WAN comment="WAN Masquerade"\n`;

    script += `\n/ip firewall filter\n`;
    script += `# Input Chain (Protect Router)\n`;
    script += `add action=drop chain=input comment="Drop Invalid" connection-state=invalid\n`;
    script += `add action=accept chain=input comment="Established" connection-state=established,related\n`;
    script += `add action=accept chain=input comment="Winbox" dst-port=8291 protocol=tcp src-address-list=management\n`;
    script += `add action=accept chain=input comment="ICMP" protocol=icmp\n`;
    script += `add action=accept chain=input comment="DNS UDP" dst-port=53 protocol=udp src-address-list=Local_Networks\n`;
    script += `add action=accept chain=input comment="DNS TCP" dst-port=53 protocol=tcp src-address-list=Local_Networks\n`;
    script += `add action=drop chain=input comment="Drop All Else"\n`;
    
    script += `# Forward Chain (Protect LAN from WAN)\n`;
    script += `add action=accept chain=forward comment="Established, Related" connection-state=established,related\n`;
    script += `add action=drop chain=forward comment="Drop Invalid" connection-state=invalid\n`;
    script += `add action=drop chain=forward comment="Drop incoming from WAN not DST-NATed" connection-nat-state=!dstnat connection-state=new in-interface-list=WAN\n`;

    // --- 9. MANGLE & PBR ---
    script += `\n# --- Policy Based Routing & Mangle ---\n`;
    script += `/ip firewall mangle\n`;
    
    wanList.forEach((wan, index) => {
        const i = index + 1;
        if (wan.type === 'pppoe') {
            script += `add action=change-mss chain=forward comment="Clamp MTU for PPPoE${i}" new-mss=clamp-to-pmtu out-interface=pppoe-out${i} passthrough=yes protocol=tcp tcp-flags=syn tcp-mss=1-65535\n`;
        }
    });

    if (pbrConfig.enabled) {
      script += `/routing table\n`;
      wanList.forEach((wan, index) => {
         script += `add name=to_wan${index + 1} fib\n`;
      });

      script += `\n/ip firewall mangle\n`;
      script += `add chain=prerouting src-address-list=Local_Networks dst-address-list=Local_Networks action=accept comment="Bypass PBR for Local Traffic"\n`;
      
      networks.forEach(net => {
        const selectedWanId = (pbrConfig.mappings && pbrConfig.mappings[net.id]) || (wanList.length > 0 ? wanList[0].id : null);
        if (selectedWanId) {
           const foundIndex = wanList.findIndex(w => String(w.id) === String(selectedWanId));
           if (foundIndex !== -1) {
              const wanNum = foundIndex + 1;
              const [gw, cidr] = net.ip.split('/');
              const ipParts = gw.split('.'); ipParts.pop();
              const networkAddr = `${ipParts.join('.')}.0/${cidr}`;
              
              script += `add chain=prerouting src-address=${networkAddr} dst-address-list=!Local_Networks action=mark-routing new-routing-mark=to_wan${wanNum} passthrough=no comment="Route ${net.name} -> WAN${wanNum}"\n`;
           }
        }
      });
      
      script += `\n/ip route\n`;
      wanList.forEach((wan, index) => {
          const i = index + 1;
          
          // เส้นทางหลักของ PBR นี้ (ทำ Recursive โดยใช้ target-scope=11 แบบที่คุณใช้เป๊ะๆ)
          script += `add dst-address=0.0.0.0/0 gateway=${wan.monitorIp} distance=1 routing-table=to_wan${i} target-scope=11 check-gateway=ping comment="PBR Primary for WAN${i}"\n`;
          
          // ระบบ Failover ภายใน PBR (โยนทราฟฟิกไปหา WAN อื่นๆ ถ้าเส้นหลักขาด)
          let backupDistance = 2;
          wanList.forEach((backupWan, backupIndex) => {
              if (index !== backupIndex) {
                  script += `add dst-address=0.0.0.0/0 gateway=${backupWan.actualGw} distance=${backupDistance} routing-table=to_wan${i} comment="PBR Backup to WAN${backupIndex + 1}"\n`;
                  backupDistance++;
              }
          });
      });
    }

    // --- 10. ENABLE VLAN FILTERING & HEARTBEAT ---
    script += `\n################################################\n`;
    script += `# Apply VLAN Filtering & Start Heartbeat\n`;
    script += `################################################\n`;
    
    script += `/interface bridge set bridge-trunk vlan-filtering=yes\n`;

    script += `/system script remove [find name="heartbeat-script"]\n`;
    script += `/system script add name="heartbeat-script" source={\n`;
    script += `  :local serverUrl "${finalApiUrl}";\n`;
    script += `  :local apiToken "${token}";\n`;
    script += `  :local cpuLoad [/system resource get cpu-load];\n`;
    script += `  :local freeMem [/system resource get free-memory];\n`;
    script += `  :local totalMem [/system resource get total-memory];\n`;
    script += `  :local usedMem ($totalMem - $freeMem);\n`;
    script += `  :local memPercent (($usedMem * 100) / $totalMem);\n`;
    script += `  :local uptime [/system resource get uptime];\n`;
    script += `  :local version [/system resource get version];\n`;
    script += `  :local boardName [/system resource get board-name];\n`;
    script += `  :local freeHdd [/system resource get free-hdd-space];\n`;
    script += `  :local totalHdd [/system resource get total-hdd-space];\n`;
    script += `  :local hddPercent 0;\n`;
    script += `  :if ($totalHdd > 0) do={ :set hddPercent (((($totalHdd - $freeHdd) * 100) / $totalHdd)) };\n`;
    script += `  :local temp "N/A";\n`;
    script += `  :do {\n`;
    script += `    :local runTemp [:parse "/system health get [find name=\\"temperature\\"] value"];\n`;
    script += `    :set temp [$runTemp];\n`;
    script += `  } on-error={};\n`;
    script += `  :local latency "timeout";\n`;
    script += `  :do { :set latency ([:tostr ([/ping 8.8.8.8 count=1 as-value]->"time")]) } on-error={};\n`;
    script += `  :local payload "{\\"cpu\\":\\"$cpuLoad\\", \\"ram\\":\\"$memPercent\\", \\"storage\\":\\"$hddPercent\\", \\"temp\\":\\"$temp\\", \\"latency\\":\\"$latency\\", \\"uptime\\":\\"$uptime\\", \\"version\\":\\"$version\\", \\"boardName\\":\\"$boardName\\"}";\n`;    
    script += `  :do {\n`;
    script += `    /tool fetch url=$serverUrl http-method=post http-header-field="Authorization: Bearer $apiToken,Content-Type: application/json" http-data=$payload keep-result=no ${fetchExtras};\n`;
    script += `  } on-error={ :log error "Failed to send Heartbeat" }\n`;
    script += `}\n`;

    script += `/system scheduler remove [find name="heartbeat-schedule"]\n`;
    script += `/system scheduler add name="heartbeat-schedule" interval=30s on-event="heartbeat-script"\n`;

    return script;

  } catch (error) {
    console.error("Generator Error:", error);
    return `# Error generating script: ${error.message}`;
  }
};